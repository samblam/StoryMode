---
interface Props {
  soundId: string;
  soundFile: string;
}

const { soundId, soundFile } = Astro.props;
---

<div class="flex flex-col w-full space-y-2" data-component-id={soundId}>
  <div class="flex items-center space-x-4">
    <span class="current-time text-sm text-gray-600 w-12">0:00</span>
    <div 
      class="relative flex-grow h-2 bg-gray-200 rounded cursor-pointer progress-bar group" 
      data-sound-id={soundId}
      data-sound-file={soundFile}
    >
      <div class="absolute h-full bg-green-400 rounded progress-fill" style="width: 0%"></div>
      <div 
        class="absolute top-1/2 -mt-2 -ml-2 w-4 h-4 bg-white rounded-full shadow-md opacity-0 group-hover:opacity-100 cursor-grab active:cursor-grabbing handle transition-opacity duration-200"
        style="left: 0%"
      ></div>
    </div>
    <span class="duration text-sm text-gray-600 w-12">0:00</span>
  </div>
</div>

<script>
  import { audioManager } from '../utils/audioManager';

  class AudioProgressController {
    private progressBar: HTMLElement;
    private progressFill: HTMLElement;
    private handle: HTMLElement;
    private currentTimeEl: HTMLElement;
    private durationEl: HTMLElement;
    private soundId: string;
    private soundFile: string;
    private isDragging: boolean = false;
    private updateInterval: number | null = null;
    private activeSound: Howl | null = null;

    constructor(progressBar: HTMLElement) {
      this.progressBar = progressBar;
      this.soundId = progressBar.dataset.soundId || '';
      this.soundFile = progressBar.dataset.soundFile || '';
      this.progressFill = progressBar.querySelector('.progress-fill') as HTMLElement;
      this.handle = progressBar.querySelector('.handle') as HTMLElement;
      this.currentTimeEl = progressBar.parentElement?.querySelector('.current-time') as HTMLElement;
      this.durationEl = progressBar.parentElement?.querySelector('.duration') as HTMLElement;

      this.validateAndInitialize();
    }

    private validateAndInitialize(): void {
      if (!this.progressBar || !this.progressFill || !this.handle || 
          !this.currentTimeEl || !this.durationEl || !this.soundFile) {
        console.error('Required elements not found for progress bar');
        return;
      }

      this.initializeEventListeners();
      this.startProgressTracking();
    }

    private formatTime(seconds: number): string {
      if (isNaN(seconds) || !isFinite(seconds)) return '0:00';
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    private updateProgressBar(percentage: number): void {
      percentage = Math.max(0, Math.min(100, percentage));
      requestAnimationFrame(() => {
        this.progressFill.style.width = `${percentage}%`;
        this.handle.style.left = `${percentage}%`;
      });
    }

    private updateTimeDisplay(currentTime: number, duration: number): void {
      requestAnimationFrame(() => {
        this.currentTimeEl.textContent = this.formatTime(currentTime);
        this.durationEl.textContent = this.formatTime(duration);
      });
    }

    private async updateCurrentSound(): Promise<Howl | null> {
      if (this.soundId === audioManager.getCurrentSoundId()) {
        if (!this.activeSound) {
          try {
            this.activeSound = await audioManager.getSound(this.soundFile, this.soundId);
          } catch (error) {
            return null;
          }
        }
        return this.activeSound;
      }
      return null;
    }

    private async seekAudio(percentage: number): Promise<void> {
      const sound = await this.updateCurrentSound();
      if (!sound) return;

      const duration = sound.duration();
      if (duration) {
        const seekTime = duration * (percentage / 100);
        sound.seek(seekTime);
        this.updateTimeDisplay(seekTime, duration);
      }
    }

    private handleMouseDown = (e: MouseEvent): void => {
      e.preventDefault();
      this.isDragging = true;
      this.handle.classList.add('opacity-100');
      this.updateFromMouseEvent(e);
      
      document.addEventListener('mousemove', this.handleMouseMove);
      document.addEventListener('mouseup', this.handleMouseUp);
    };

    private handleMouseMove = (e: MouseEvent): void => {
      if (!this.isDragging) return;
      this.updateFromMouseEvent(e);
    };

    private handleMouseUp = (): void => {
      if (!this.isDragging) return;
      this.isDragging = false;
      
      if (!audioManager.isPlaying()) {
        this.handle.classList.remove('opacity-100');
      }

      document.removeEventListener('mousemove', this.handleMouseMove);
      document.removeEventListener('mouseup', this.handleMouseUp);
    };

    private updateFromMouseEvent(e: MouseEvent): void {
      const rect = this.progressBar.getBoundingClientRect();
      const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
      const percentage = (x / rect.width) * 100;
      
      this.updateProgressBar(percentage);
      this.seekAudio(percentage);
    }

    private initializeEventListeners(): void {
      this.progressBar.addEventListener('mousedown', this.handleMouseDown);
      
      document.addEventListener('audioend', (e: Event) => {
        const customEvent = e as CustomEvent;
        if (customEvent.detail.soundId === this.soundId) {
          this.updateProgressBar(0);
          this.updateTimeDisplay(0, customEvent.detail.duration || 0);
          this.handle.classList.remove('opacity-100');
          this.activeSound = null;
        }
      });

      // Clear active sound when audio changes
      document.addEventListener('audiochange', () => {
        this.activeSound = null;
      });
    }

    private async startProgressTracking(): Promise<void> {
      if (this.updateInterval) {
        window.clearInterval(this.updateInterval);
      }

      this.updateInterval = window.setInterval(async () => {
        if (this.isDragging) return;

        const sound = await this.updateCurrentSound();
        if (!sound?.playing()) return;

        const seek = sound.seek() as number;
        const duration = sound.duration();

        if (duration > 0) {
          const percentage = (seek / duration) * 100;
          this.updateProgressBar(percentage);
          this.updateTimeDisplay(seek, duration);
          this.handle.classList.add('opacity-100');
        }
      }, 250); // Reduced update frequency
    }

    public cleanup(): void {
      if (this.updateInterval) {
        window.clearInterval(this.updateInterval);
      }
      
      this.progressBar.removeEventListener('mousedown', this.handleMouseDown);
      document.removeEventListener('mousemove', this.handleMouseMove);
      document.removeEventListener('mouseup', this.handleMouseUp);
      
      this.activeSound = null;
    }
  }

  // Initialize progress bars
  const controllers = new Map<string, AudioProgressController>();

  document.querySelectorAll('.progress-bar[data-sound-id]').forEach(progressBar => {
    if (progressBar instanceof HTMLElement) {
      const soundId = progressBar.dataset.soundId;
      if (soundId) {
        const controller = new AudioProgressController(progressBar);
        controllers.set(soundId, controller);
      }
    }
  });

  // Cleanup on page unload
  window.addEventListener('unload', () => {
    controllers.forEach(controller => controller.cleanup());
    controllers.clear();
  });
</script>